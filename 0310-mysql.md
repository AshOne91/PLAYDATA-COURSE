**데이터베이스(Database)**는 체계적으로 조직된 데이터의 집합으로, 다수의 사용자나 애플리케이션이 데이터를 효율적으로 저장, 관리, 검색, 수정할 수 있도록 설계된 시스템입니다.  

### **데이터베이스의 주요 특징**
1. **데이터 무결성(Integrity)**: 데이터의 정확성과 일관성을 유지해야 합니다.  
2. **데이터 중복 최소화(Redundancy Reduction)**: 동일한 데이터가 여러 곳에 저장되지 않도록 설계됩니다.  
3. **데이터 독립성(Independence)**: 데이터 구조와 애플리케이션이 서로 독립적으로 변경될 수 있습니다.  
4. **데이터 보안(Security)**: 접근 제어 및 권한 설정을 통해 데이터 보호가 가능합니다.  
5. **동시성 제어(Concurrency Control)**: 여러 사용자가 동시에 접근할 때도 데이터의 일관성을 유지해야 합니다.  
6. **백업과 복구(Backup & Recovery)**: 장애 발생 시 데이터 손실을 방지하기 위한 기능을 제공합니다.  

### **데이터베이스의 유형**
1. **관계형 데이터베이스(RDBMS)**  
   - 데이터를 테이블 형식으로 저장하며, SQL을 사용해 데이터를 조작  
   - 대표적인 예: MySQL, PostgreSQL, Oracle, SQL Server  

2. **NoSQL 데이터베이스**  
   - 비정형 데이터나 대량의 데이터를 효율적으로 처리  
   - Key-Value Store, Document Store, Column Store, Graph DB 등의 유형이 있음  
   - 대표적인 예: MongoDB, Redis, Cassandra, Neo4j  

3. **인메모리 데이터베이스(IMDB)**  
   - 데이터를 메모리에 저장하여 빠른 속도를 제공  
   - 대표적인 예: Redis, Memcached  

4. **클라우드 기반 데이터베이스**  
   - 클라우드 환경에서 제공되는 DB 서비스  
   - 대표적인 예: Amazon RDS, Google Cloud Spanner, Firebase  

데이터베이스는 IT 시스템의 핵심 요소로, 효율적인 데이터 관리와 빠른 검색을 가능하게 하여 다양한 응용 프로그램에서 필수적으로 사용됩니다.


### **데이터베이스 핵심 개념 정리**  

1. **구조화(Structuring)**  
   - 데이터를 **체계적으로 설계**하는 과정  
   - **스키마**(데이터 구조), **정규화**(중복 최소화) 포함  

2. **무결성(Integrity)**  
   - 데이터의 **정확성과 일관성 유지**  
   - **개체 무결성**(PK 중복X, NULL X)  
   - **참조 무결성**(FK는 존재하는 값만 가능)  
   - **도메인 무결성**(값의 범위 제한)  

3. **접근성(Accessibility)**  
   - 데이터를 **효율적으로 조회, 관리**하는 기능  
   - **SQL 사용**, **트랜잭션 관리(ACID)**  
   - **권한 관리**, **인덱스 활용(빠른 검색)**  

**➡ 한 줄 요약:**  
데이터베이스는 **구조화된 방식으로 데이터를 저장**하고, **무결성을 유지하면서** 효율적으로 **접근할 수 있도록 관리**하는 시스템.

### **CRUD 개념 정리**  

**CRUD**는 데이터베이스에서 데이터를 **관리하는 기본 연산**을 의미하며, 다음과 같이 네 가지로 구성됩니다.  

1. **Create (생성)**
   - 데이터를 **추가**하는 연산  
   - SQL 예제:  
     ```sql
     INSERT INTO users (id, name, age) VALUES (1, '성호', 34);
     ```

2. **Read (조회)**
   - 데이터를 **읽거나 검색**하는 연산  
   - SQL 예제:  
     ```sql
     SELECT * FROM users WHERE id = 1;
     ```

3. **Update (수정)**
   - 기존 데이터를 **수정**하는 연산  
   - SQL 예제:  
     ```sql
     UPDATE users SET age = 35 WHERE id = 1;
     ```

4. **Delete (삭제)**
   - 데이터를 **삭제**하는 연산  
   - SQL 예제:  
     ```sql
     DELETE FROM users WHERE id = 1;
     ```

**➡ 한 줄 요약:**  
CRUD는 **데이터 추가(Create), 조회(Read), 수정(Update), 삭제(Delete)**의 기본 연산을 의미하며, 대부분의 데이터베이스 및 애플리케이션에서 사용됨.

### **SQL의 주요 분류: DDL, DML, DCL**  

SQL은 기능에 따라 **DDL, DML, DCL** 세 가지로 나뉩니다.  

---

## **1. DDL (Data Definition Language, 데이터 정의어)**
- **데이터베이스 객체(테이블, 인덱스 등)를 생성, 수정, 삭제**하는 명령어  
- 데이터의 **구조(스키마)를 정의**하는 역할  
- **트랜잭션 롤백 불가** (자동 반영됨)  

🔹 **주요 명령어**  
```sql
CREATE TABLE users (id INT, name VARCHAR(50));  -- 테이블 생성
ALTER TABLE users ADD age INT;                  -- 테이블 수정
DROP TABLE users;                               -- 테이블 삭제
TRUNCATE TABLE users;                           -- 테이블 데이터 초기화
```

---

## **2. DML (Data Manipulation Language, 데이터 조작어)**
- **데이터를 삽입, 조회, 수정, 삭제**하는 명령어  
- 데이터의 **값을 변경하는 작업**  
- **트랜잭션(ROLLBACK, COMMIT) 가능**  

🔹 **주요 명령어**  
```sql
INSERT INTO users (id, name) VALUES (1, '성호');  -- 데이터 삽입
SELECT * FROM users;                              -- 데이터 조회
UPDATE users SET name = '권성호' WHERE id = 1;   -- 데이터 수정
DELETE FROM users WHERE id = 1;                  -- 데이터 삭제
```

---

## **3. DCL (Data Control Language, 데이터 제어어)**
- **사용자 권한을 부여하거나 회수하는 명령어**  
- 데이터의 **보안 및 접근 제어** 관리  

🔹 **주요 명령어**  
```sql
GRANT SELECT ON users TO user1;   -- 사용자에게 조회 권한 부여
REVOKE SELECT ON users FROM user1; -- 조회 권한 회수
```

---

### **정리**
| 분류  | 설명 | 주요 명령어 |
|------|------|-----------|
| **DDL** | 데이터 구조 정의 (테이블, 인덱스 등) | `CREATE`, `ALTER`, `DROP`, `TRUNCATE` |
| **DML** | 데이터 조작 (삽입, 조회, 수정, 삭제) | `INSERT`, `SELECT`, `UPDATE`, `DELETE` |
| **DCL** | 권한 부여 및 회수 | `GRANT`, `REVOKE` |

**➡ 한 줄 요약:**  
- **DDL**: 데이터 구조 정의  
- **DML**: 데이터 삽입, 조회, 수정, 삭제  
- **DCL**: 데이터 접근 권한 관리
  
  ---
  ### **DBA(Database Administrator) 필수 지식 목차**  

#### **1. 데이터베이스 개념 및 원리**  
   - 데이터베이스 기본 개념 (DBMS, RDBMS, NoSQL)  
   - ACID 특성 (Atomicity, Consistency, Isolation, Durability)  
   - 트랜잭션 관리 및 동시성 제어  
   - 데이터 무결성 (개체 무결성, 참조 무결성, 도메인 무결성)  

#### **2. 데이터베이스 설계 및 최적화**  
   - 데이터 모델링 (개념적, 논리적, 물리적 설계)  
   - 정규화(NF1~NF5) 및 비정규화 전략  
   - 인덱스 설계 및 활용 (B-Tree, Hash Index 등)  
   - 파티셔닝 및 샤딩 개념  

#### **3. SQL 및 성능 튜닝**  
   - SQL 기본 및 고급 문법 (DDL, DML, DCL, TCL)  
   - 조인(Join) 및 서브쿼리 최적화  
   - 실행 계획(EXPLAIN, EXPLAIN ANALYZE) 분석  
   - 인덱스 활용 및 쿼리 최적화 전략  
   - Stored Procedure, Trigger, View 활용  

#### **4. 데이터베이스 관리 및 운영**  
   - 백업 및 복구 전략 (Full, Incremental, Differential Backup)  
   - 장애 대응 및 복구 절차 (Redo, Undo Log)  
   - 모니터링 및 성능 분석 (Slow Query Log, DB Metrics)  
   - 고가용성(HA, High Availability) 및 복제 기술 (Replication, Cluster)  

#### **5. 보안 및 접근 제어**  
   - 사용자 계정 및 권한 관리 (GRANT, REVOKE)  
   - 데이터 암호화 및 마스킹  
   - 감사(Audit) 및 로그 관리  
   - 보안 정책 및 컴플라이언스 (GDPR, HIPAA 등)  

#### **6. 최신 기술 및 트렌드**  
   - 클라우드 DBMS (AWS RDS, Azure SQL, Google Cloud SQL)  
   - NoSQL (MongoDB, Redis, Cassandra) 개념 및 활용  
   - 빅데이터 및 데이터 웨어하우스 (Hadoop, Snowflake)  
   - 자동화 및 DevOps (CI/CD, Infrastructure as Code)  

**➡ 한 줄 요약:**  
DBA는 **데이터 모델링, SQL 최적화, 성능 튜닝, 보안, 백업 및 복구, 최신 DB 기술**을 다룰 수 있어야 함.
### **데이터베이스 기본 개념 정리**  

## **1. DBMS (Database Management System)**
- **정의:** 데이터를 체계적으로 저장, 관리하는 소프트웨어  
- **목적:** 데이터 무결성 유지, 동시 접근 처리, 보안 강화  
- **특징:**  
  - 데이터를 효율적으로 **CRUD**(생성, 조회, 수정, 삭제)  
  - **트랜잭션 관리**(ACID 특성)  
  - 다중 사용자 환경에서 **동시성 제어**  
  - **데이터 백업 및 복구** 지원  

✅ **대표적인 DBMS 종류**  
- **관계형 DBMS (RDBMS):** MySQL, PostgreSQL, Oracle, MS SQL Server  
- **비관계형 DBMS (NoSQL):** MongoDB, Redis, Cassandra  

---

## **2. RDBMS (Relational Database Management System)**
- **정의:** 데이터를 **테이블(표)** 형식으로 저장하고, **관계(Relationship)** 를 이용해 연결하는 DBMS  
- **특징:**  
  - **정규화(Normalization)** 를 통해 중복 최소화  
  - **SQL (Structured Query Language)** 를 사용  
  - **트랜잭션 지원(ACID)** 으로 데이터 일관성 보장  

✅ **RDBMS의 핵심 개념**  
- **테이블(Table)**: 데이터를 행(Row)과 열(Column)로 구성  
- **기본 키(Primary Key, PK)**: 각 행을 고유하게 식별하는 키  
- **외래 키(Foreign Key, FK)**: 다른 테이블과 관계를 맺는 키  
- **JOIN 연산**: 여러 테이블을 연결하여 데이터 조회  

🔹 **RDBMS 예제 (MySQL)**  
```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100) UNIQUE
);
```

---

## **3. NoSQL (Not Only SQL)**
- **정의:** 전통적인 RDBMS의 테이블 구조 대신 **유연한 데이터 모델**을 제공하는 DBMS  
- **특징:**  
  - **수직 확장(Scale-up)보다 수평 확장(Scale-out) 용이**  
  - **스키마가 유연함** (정해진 구조 없이 저장 가능)  
  - **비정형 데이터(Big Data) 처리에 최적화**  

✅ **NoSQL의 주요 유형**  
| 유형 | 설명 | 예제 |
|------|------|------|
| **키-값(Key-Value) 저장소** | Key에 대한 Value 저장 | Redis, DynamoDB |
| **문서(Document) DB** | JSON 형태로 저장 | MongoDB, CouchDB |
| **열(Column) 기반 DB** | 컬럼 단위로 저장 (분산 처리에 최적) | Cassandra, HBase |
| **그래프(Graph) DB** | 노드-간선 구조 저장 (소셜 네트워크 분석) | Neo4j |

🔹 **NoSQL 예제 (MongoDB)**  
```json
{
    "id": 1,
    "name": "성호",
    "email": "seongho@example.com"
}
```

---

## **비교 요약: RDBMS vs NoSQL**  

| 항목 | RDBMS | NoSQL |
|------|------|------|
| **데이터 모델** | 테이블 기반 | JSON, Key-Value, 그래프 등 |
| **확장성** | 수직 확장(Scale-up) | 수평 확장(Scale-out) |
| **트랜잭션 지원** | ACID 보장 | 대부분 BASE(최종적 일관성) |
| **쿼리 언어** | SQL 사용 | NoSQL 방식 (JSON, Key-Value) |
| **사용 사례** | 전통적인 기업 시스템, 금융 | 빅데이터, 실시간 분석, 분산 시스템 |

---

### **📌 정리**
- **DBMS:** 데이터를 저장, 관리하는 시스템  
- **RDBMS:** 관계형 데이터베이스, 테이블 기반, SQL 사용, ACID 보장  
- **NoSQL:** 비관계형 데이터베이스, 스키마 유연, 수평 확장 용이  

**➡ 다음으로 공부할 주제 선택:**
1. **ACID 특성**
2. **트랜잭션 관리**
3. **데이터 무결성**  
4. **정규화와 비정규화**  
5. **NoSQL 심화 (각 유형별 특성 비교)**  

### **ACID 특성**  

ACID는 **트랜잭션(Transaction)** 이 안전하게 실행되기 위한 4가지 핵심 원칙입니다.  
트랜잭션은 데이터베이스에서 **일련의 작업을 하나의 단위로 처리**하는 것을 의미합니다.  

---

## **1. ACID란?**
| 속성 | 설명 |
|------|------|
| **A (Atomicity, 원자성)** | 트랜잭션 내 모든 작업이 **완전히 실행되거나 완전히 취소됨 (ALL or NOTHING)** |
| **C (Consistency, 일관성)** | 트랜잭션 실행 전후에 **데이터 무결성이 유지됨** |
| **I (Isolation, 고립성)** | 동시에 여러 트랜잭션이 실행될 때 **서로 간섭하지 않음** |
| **D (Durability, 지속성)** | 트랜잭션이 완료되면 **데이터가 영구적으로 저장됨** |

---

## **2. ACID 속성 상세 설명 및 예제**  

### **1️⃣ Atomicity (원자성)**
**"트랜잭션은 완전히 실행되거나, 아예 실행되지 않아야 한다."**  
- 트랜잭션 도중 오류가 발생하면 **롤백(Rollback)** 되어야 함  
- 중간 단계에서 일부만 적용되면 안 됨  

✅ **예제:** 은행 계좌 송금  
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- A 계좌에서 출금
UPDATE accounts SET balance = balance + 100 WHERE id = 2;  -- B 계좌로 입금
COMMIT;  -- 둘 다 성공하면 반영
```
**🚨 문제 발생 시:**
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 네트워크 오류 발생 💥
ROLLBACK;  -- 모든 변경사항 취소
```
**결과:** A 계좌에서 돈이 빠져나갔는데 B 계좌에 입금되지 않는 문제 방지  

---

### **2️⃣ Consistency (일관성)**
**"데이터는 항상 유효한 상태를 유지해야 한다."**  
- 트랜잭션이 실행된 후에도 **데이터 무결성이 보장되어야 함**  
- 참조 무결성, 제약 조건(Constraints)을 위반하면 트랜잭션이 실행되지 않음  

✅ **예제:** 학생 성적 테이블에서 성적이 0~100 사이가 아니라면 저장되지 않음  
```sql
CREATE TABLE scores (
    student_id INT PRIMARY KEY,
    score INT CHECK (score BETWEEN 0 AND 100)  -- 0~100 범위만 허용
);
```
```sql
INSERT INTO scores VALUES (1, 110);  -- ❌ 오류 발생 (일관성 위배)
```

---

### **3️⃣ Isolation (고립성)**
**"동시에 실행되는 트랜잭션은 서로 간섭하지 않아야 한다."**  
- **트랜잭션 격리 수준(Transaction Isolation Level)** 설정 가능  
- 동시에 실행되는 트랜잭션이 **서로 충돌하지 않도록 보호**  

✅ **예제:** 두 사용자가 동시에 같은 상품을 구매할 때  
```sql
BEGIN;
SELECT stock FROM products WHERE id = 1;  -- 현재 재고 조회 (10개)
UPDATE products SET stock = stock - 1 WHERE id = 1;  -- 재고 감소
COMMIT;
```
💥 **문제점:** 두 사용자가 동시에 조회하면 재고가 10개로 보이지만, 실제로는 1개 부족할 수도 있음  
➡ 이를 방지하려면 **격리 수준 설정** 필요  

**🚀 해결 방법:**  
- `SERIALIZABLE`: 가장 강력한 격리 수준 (성능 저하 있음)  
- `REPEATABLE READ`: 같은 트랜잭션 내에서는 같은 결과 조회  

---

### **4️⃣ Durability (지속성)**
**"트랜잭션이 완료되면, 시스템 장애가 발생해도 데이터는 손실되지 않는다."**  
- 트랜잭션이 **COMMIT 된 후에는 데이터가 영구적으로 저장**  
- 장애가 발생해도 데이터가 유지되도록 **로그 파일, WAL(Write-Ahead Logging) 사용**  

✅ **예제:** 은행 시스템에서 거래 내역 저장  
```sql
BEGIN;
INSERT INTO transactions (user_id, amount) VALUES (1, 500);
COMMIT;  -- 트랜잭션 완료 후 데이터 영구 저장
```
💥 **장애 발생 시**  
- **COMMIT 전:** ROLLBACK 가능 (데이터 반영 X)  
- **COMMIT 후:** 시스템이 다운되어도 데이터 유지됨  

---

## **3. ACID 특성이 중요한 이유**
- **데이터 무결성 보장:** 데이터가 일관되고 신뢰할 수 있도록 유지  
- **데이터 손실 방지:** 시스템 장애 시에도 복구 가능  
- **동시성 제어:** 여러 사용자가 동시에 DB를 사용해도 안전하게 처리  
- **신뢰성 높은 시스템:** 금융, 결제, ERP 등 중요한 시스템에서 필수  

---

### **📌 정리**
| 속성 | 설명 | 키워드 |
|------|------|------|
| **Atomicity** (원자성) | 트랜잭션은 **완전히 실행되거나, 전혀 실행되지 않아야 함** | `ROLLBACK`, `COMMIT` |
| **Consistency** (일관성) | 트랜잭션 전후 데이터 무결성 유지 | `CHECK`, `FOREIGN KEY` |
| **Isolation** (고립성) | 동시에 실행되는 트랜잭션이 간섭하지 않음 | `SERIALIZABLE`, `READ COMMITTED` |
| **Durability** (지속성) | 트랜잭션 완료 후 영구 저장 | `WAL`, `로그` |

**➡ 다음 학습 주제 선택:**
1. **트랜잭션 관리 및 동시성 제어** (Isolation Level, Deadlock)  
2. **데이터 무결성 (개체, 참조, 도메인 무결성)**  
3. **정규화(Normalization)와 비정규화**  
4. **데이터베이스 인덱스와 성능 최적화**
---
### **트랜잭션 관리 및 동시성 제어**  

데이터베이스에서 여러 사용자가 동시에 데이터를 변경하면 **데이터 정합성 문제**가 발생할 수 있습니다. 이를 해결하기 위해 **트랜잭션 관리(Transaction Management)** 와 **동시성 제어(Concurrency Control)** 가 필요합니다.

---

## **1. 트랜잭션(Transaction)이란?**
**트랜잭션(Transaction)** 은 **하나의 논리적 작업 단위**를 의미하며, 데이터베이스에서 **완전하게 실행되거나, 아예 실행되지 않아야 함** (Atomicity).  

✅ **예제:** 은행 송금  
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- A 계좌 출금
UPDATE accounts SET balance = balance + 100 WHERE id = 2;  -- B 계좌 입금
COMMIT;  -- 트랜잭션 완료
```
🚨 **중간에 오류 발생하면?**  
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 💥 시스템 오류 발생
ROLLBACK;  -- 모든 변경 취소
```
**결과:** A에서 돈이 빠지고 B에 입금되지 않는 문제 방지

---

## **2. 트랜잭션 격리 수준 (Isolation Levels)**
트랜잭션이 동시에 실행될 때 **서로 간섭하지 않도록 고립(Isolation)** 해야 합니다.  
격리 수준이 낮을수록 성능은 좋아지지만, 데이터 정합성 문제가 발생할 수 있습니다.

### **격리 수준 종류**
| 격리 수준 | Dirty Read | Non-repeatable Read | Phantom Read | 설명 |
|----------|-----------|--------------------|-------------|------|
| **READ UNCOMMITTED** | O | O | O | 가장 낮은 격리 수준, 커밋되지 않은 데이터 읽기 가능 |
| **READ COMMITTED** (기본) | X | O | O | 트랜잭션이 **커밋된 데이터만 읽을 수 있음** |
| **REPEATABLE READ** | X | X | O | 같은 트랜잭션 내에서 같은 데이터를 **항상 동일하게 조회** 가능 |
| **SERIALIZABLE** | X | X | X | 가장 강력한 격리 수준, **완전한 순차 실행 (성능 저하 가능)** |

✅ **격리 수준 설정 예제**
```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```
```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

---

## **3. 동시성 제어 문제 & 해결 방법**
여러 트랜잭션이 동시에 실행될 때 발생하는 문제와 해결 방법입니다.

### **1️⃣ Dirty Read (더러운 읽기)**
- **문제:** 한 트랜잭션이 **커밋되지 않은 데이터**를 읽음  
- **예제:**  
  - A가 100원을 200원으로 변경했지만, **커밋 전**
  - B가 A의 데이터를 읽으면 200원이지만, A가 롤백하면 데이터가 원래대로 돌아감  
  - B는 잘못된 데이터를 읽은 셈  

✅ **해결 방법:** `READ COMMITTED` 이상 사용  

---

### **2️⃣ Non-Repeatable Read (비반복적 읽기)**
- **문제:** 같은 데이터를 두 번 읽었을 때 값이 달라짐  
- **예제:**  
  - 트랜잭션 A가 같은 데이터를 두 번 조회했을 때,  
  - 그 사이에 트랜잭션 B가 데이터를 변경 후 커밋하면  
  - A가 조회한 결과가 달라짐  

✅ **해결 방법:** `REPEATABLE READ` 이상 사용  

---

### **3️⃣ Phantom Read (팬텀 읽기)**
- **문제:** 한 트랜잭션에서 조회한 데이터 집합이 이후 다시 조회했을 때 달라짐 (새로운 행 추가/삭제)  
- **예제:**  
  - 트랜잭션 A가 특정 조건(`WHERE`)을 만족하는 행을 조회  
  - 그 사이에 트랜잭션 B가 새로운 행을 삽입하고 커밋  
  - 다시 조회하면 새로운 행이 추가됨  

✅ **해결 방법:** `SERIALIZABLE` 사용  

---

## **4. 동시성 제어 기법**
동시성 문제를 해결하기 위해 **Locking(잠금)과 MVCC(다중 버전 동시성 제어)** 방법이 사용됩니다.

### **1️⃣ Locking (잠금)**
- **Shared Lock (S)**: **읽기 잠금 (다른 트랜잭션이 읽을 수는 있지만, 수정은 불가)**  
- **Exclusive Lock (X)**: **쓰기 잠금 (다른 트랜잭션이 읽기/쓰기 불가)**  

✅ **예제**
```sql
-- 공유 잠금 (S)
SELECT * FROM accounts WHERE id = 1 LOCK IN SHARE MODE;

-- 배타 잠금 (X)
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
```

---

### **2️⃣ MVCC (Multi-Version Concurrency Control)**
- **읽기 잠금 없이 트랜잭션별로 데이터를 다르게 보이게 하는 기법**
- **PostgreSQL, MySQL (InnoDB), Oracle에서 사용됨**
- 트랜잭션이 시작될 때 데이터의 **스냅샷을 유지** → 변경된 데이터는 별도 저장  

✅ **MVCC 특징**
- `READ COMMITTED` → 트랜잭션마다 최신 커밋된 데이터 조회  
- `REPEATABLE READ` → 트랜잭션 시작 시점의 데이터 유지  

---

## **5. 데드락 (Deadlock)**
**서로가 필요한 자원을 잠그고 있어서, 아무도 진행할 수 없는 상태**  
예를 들어,  
- 트랜잭션 A: **Row 1 잠금 → Row 2 요청**
- 트랜잭션 B: **Row 2 잠금 → Row 1 요청**
→ **서로가 상대방의 잠금을 기다리면서 영원히 멈춤**

✅ **해결 방법**
1. **트랜잭션 실행 순서를 통제**  
   ```sql
   UPDATE accounts SET balance = balance - 100 WHERE id = 1;
   UPDATE accounts SET balance = balance + 100 WHERE id = 2;
   ```
   → 항상 같은 순서로 실행  

2. **타임아웃 설정**
   ```sql
   SET innodb_lock_wait_timeout = 5;
   ```
   → 5초 이상 잠금 대기 시 트랜잭션 자동 취소  

---

## **📌 정리**
| 개념 | 설명 | 해결 방법 |
|------|------|-----------|
| **Dirty Read** | 커밋되지 않은 데이터를 읽음 | `READ COMMITTED` |
| **Non-repeatable Read** | 같은 데이터를 두 번 조회 시 값이 달라짐 | `REPEATABLE READ` |
| **Phantom Read** | 조회 시 데이터 집합이 다르게 보임 | `SERIALIZABLE` |
| **Deadlock** | 트랜잭션이 서로의 잠금을 기다리면서 멈춤 | 트랜잭션 순서 통제, 타임아웃 설정 |

---

### **다음 학습 주제 선택**
1. **데이터 무결성 (개체, 참조, 도메인 무결성)**
2. **정규화(Normalization)와 비정규화**
3. **데이터베이스 인덱스와 성능 최적화**

MySQL을 기준으로 **트랜잭션(Transaction)**과 **락(Lock)**의 차이를 설명하겠습니다.

---

## **1. 트랜잭션(Transaction)**
MySQL에서 트랜잭션은 여러 SQL 명령어를 하나의 논리적 작업 단위로 묶어서 처리하는 것입니다. 트랜잭션을 사용하면 데이터의 **ACID** 특성(원자성, 일관성, 격리성, 지속성)을 보장할 수 있습니다.

### **트랜잭션의 주요 명령어**
- `BEGIN` 또는 `START TRANSACTION`: 트랜잭션 시작
- `COMMIT`: 트랜잭션 종료 및 변경사항 저장
- `ROLLBACK`: 트랜잭션 취소 및 이전 상태로 복구

### **트랜잭션 예시**
```sql
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- A 계좌 출금
UPDATE accounts SET balance = balance + 100 WHERE id = 2;  -- B 계좌 입금
COMMIT;  -- 트랜잭션 완료 (변경사항 확정)
```

- 트랜잭션 내에서 발생하는 두 개의 `UPDATE` 문이 **하나의 작업 단위로 묶입니다.**
- 트랜잭션이 끝나기 전에 오류가 발생하면 **ROLLBACK**을 통해 변경된 내용을 모두 취소할 수 있습니다.

---

## **2. 락(Lock)**
MySQL에서 **락**은 **동시에 여러 트랜잭션이 같은 데이터에 접근하는 경우 데이터 정합성을 유지하기 위한 메커니즘**입니다. 락을 사용하면 다른 트랜잭션이 동일한 데이터에 대해 읽기/수정/삭제 작업을 수행하는 것을 방지할 수 있습니다.

### **락의 종류**
MySQL에서는 **공유 락**(S lock)과 **배타 락**(X lock) 등을 제공합니다. 락은 보통 **`SELECT`** 쿼리에서 `FOR UPDATE`나 `LOCK IN SHARE MODE`와 함께 사용합니다.

1. **공유 락 (Shared Lock)**: 다른 트랜잭션이 데이터를 **읽을 수는 있지만 수정할 수는 없다.**
   - **읽기 전용 작업**에서 사용
   - 예시: `SELECT ... LOCK IN SHARE MODE`
   
   ```sql
   SELECT * FROM accounts WHERE id = 1 LOCK IN SHARE MODE;
   ```

2. **배타 락 (Exclusive Lock)**: 다른 트랜잭션이 **읽기/수정/삭제를 할 수 없도록 완전히 잠근다.**
   - **수정 작업**에서 사용
   - 예시: `SELECT ... FOR UPDATE`
   
   ```sql
   SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
   ```

---

## **트랜잭션과 락의 관계 (MySQL 기준)**
MySQL에서는 트랜잭션이 실행될 때 **자동으로 락을 설정할 수 있으며, 락은 트랜잭션이 종료될 때 해제됩니다**.

### **예시 1: `SELECT ... FOR UPDATE` (배타 락)**
```sql
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;  -- 해당 행을 배타 락으로 잠금
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- 트랜잭션 내에서 수정
COMMIT;
```
- **`SELECT ... FOR UPDATE`**는 **배타 락**을 사용하여 다른 트랜잭션이 해당 데이터를 수정하지 못하도록 잠급니다.
- 트랜잭션이 끝날 때까지 이 데이터는 다른 트랜잭션에서 수정할 수 없습니다.

### **예시 2: `SELECT ... LOCK IN SHARE MODE` (공유 락)**
```sql
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1 LOCK IN SHARE MODE;  -- 해당 행을 공유 락으로 잠금
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- 다른 트랜잭션이 데이터를 수정할 수 없음
COMMIT;
```
- **`LOCK IN SHARE MODE`**는 **공유 락**을 사용하여 다른 트랜잭션이 해당 데이터를 읽을 수 있도록 허용하지만, 수정은 못하게 합니다.

---

## **트랜잭션과 락의 차이**
| **구분**           | **트랜잭션 (Transaction)**                | **락 (Lock)**                         |
|-------------------|------------------------------------------|--------------------------------------|
| **정의**           | 여러 SQL 명령어를 하나의 작업 단위로 묶은 것 | 데이터 정합성을 유지하기 위해 동시 접근 제어 |
| **목적**           | ACID 원칙을 보장하여 데이터 정합성 유지   | 동시에 접근하는 트랜잭션들 간 충돌을 방지 |
| **필수 여부**       | 트랜잭션은 반드시 필요                   | 락은 트랜잭션 내에서 필요한 경우에만 사용 |
| **사용 방법**       | `START TRANSACTION`, `COMMIT`, `ROLLBACK` | `SELECT ... FOR UPDATE`, `LOCK IN SHARE MODE` |
| **적용 대상**       | 여러 SQL 명령어                          | 특정 데이터 행(Row) 또는 테이블(Table) |
| **동작**            | 모든 쿼리가 하나의 단위로 처리됨         | 데이터에 락을 걸어 다른 트랜잭션의 접근을 제어 |

---

## **결론**
- **트랜잭션**은 **하나의 작업 단위**로 여러 SQL 명령어를 묶어 **ACID 특성을 보장**하고, 데이터의 **정합성을 유지**합니다.
- **락**은 여러 트랜잭션이 동시에 같은 데이터를 수정하거나 읽을 때 데이터의 **정합성을 보호**하기 위해 **동시성**을 관리하는 **메커니즘**입니다.

💡 **이해를 돕기 위한 핵심 포인트**  
- 트랜잭션은 작업의 **완결성**을 보장하고, 락은 **동시 작업**에서의 충돌을 방지합니다.
- 트랜잭션이 실행될 때, 락이 사용될 수 있으며, 락은 **수정 작업**(배타 락)이나 **읽기 작업**(공유 락)에서 사용됩니다.

---

### **다음 학습 주제 제안**  
1️⃣ **트랜잭션 격리 수준 (Isolation Levels)**  
2️⃣ **데드락(Deadlock) 해결 방법**  
3️⃣ **MVCC (다중 버전 동시성 제어) 심화**

네, 맞습니다! MySQL에서 **레코드당 락**이 자동으로 잡히는 방식은 **InnoDB 스토리지 엔진**에서 **행 수준의 락**(row-level locking)을 사용하기 때문입니다. MySQL은 기본적으로 **InnoDB** 엔진을 사용하며, 이 엔진은 **트랜잭션 격리**를 보장하고 **ACID** 특성을 지원하기 위해 자동으로 락을 관리합니다.

### **InnoDB의 자동 행 수준 락**
InnoDB는 **레코드**(혹은 행)에 대해 **자동으로 락을 잡을 수** 있습니다. 이는 **데이터 무결성**과 **동시성**을 보장하기 위한 중요한 메커니즘입니다. **InnoDB는 기본적으로 SELECT, UPDATE, DELETE 작업을 수행할 때 자동으로 행 수준의 락을 사용**합니다. 트랜잭션을 사용하지 않아도, **자동으로 락이 발생**할 수 있습니다.

### **자동 락이 적용되는 경우**
1. **`SELECT ... FOR UPDATE`**: 데이터를 수정할 목적으로 행을 선택할 때, **배타 락**(exclusive lock)이 자동으로 설정됩니다.
2. **`SELECT ... LOCK IN SHARE MODE`**: 다른 트랜잭션이 데이터를 수정하지 못하게 하는 **공유 락**(shared lock)이 자동으로 설정됩니다.
3. **`UPDATE` / `DELETE`**: 데이터를 수정하거나 삭제하는 경우, 해당 레코드에 **배타 락**이 자동으로 설정됩니다. (업데이트하는 레코드에 대해 자동으로 락이 걸립니다)

### **자동으로 락이 잡히는 방식**
1. **행 수준의 락 (Row-level Locking)**  
   - InnoDB는 **행 수준의 락**을 사용하여, 한 번에 하나의 트랜잭션만 특정 행을 수정하도록 제한합니다.
   - 예를 들어, **`UPDATE`** 쿼리가 실행되면 해당 행에 대해서 **배타 락**(exclusive lock)을 자동으로 적용하고, 다른 트랜잭션은 해당 행을 수정할 수 없게 됩니다.
   - **`SELECT ... FOR UPDATE`** 쿼리로 해당 행을 선택하면, 그 행에 대해서 **배타 락**이 적용되어, 다른 트랜잭션에서 해당 행을 수정할 수 없습니다.

2. **버퍼 풀에서 자동 락**  
   - InnoDB는 데이터를 디스크에서 읽어올 때, 데이터를 **버퍼 풀**에 캐시합니다. 이때도 데이터를 수정하려면 해당 레코드에 대한 **행 수준의 락**을 획득합니다.
   
3. **락 해제 시점**  
   - **COMMIT**이 발생하면 락이 해제됩니다. 트랜잭션이 완료되면, 그 트랜잭션에서 사용했던 락도 자동으로 해제됩니다.
   - **ROLLBACK**이 발생하면, 트랜잭션에서 사용한 락이 해제되고, 이전 상태로 복구됩니다.

### **예시: 자동 락이 적용되는 상황**
```sql
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;  -- 배타 락을 자동으로 설정
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- 이미 락이 걸린 행을 수정
COMMIT;  -- 트랜잭션 종료, 락 해제
```
1. **`SELECT ... FOR UPDATE`** 문이 실행될 때, `id = 1`인 행에 대해 **배타 락**이 자동으로 설정됩니다.
2. **`UPDATE`** 문이 실행될 때, 이미 락이 걸린 상태이므로 해당 행을 수정할 수 있습니다.
3. **`COMMIT`**이 호출되면, 락이 해제되고 트랜잭션이 종료됩니다.

### **자동 락 처리 방식**
InnoDB는 기본적으로 **행 수준의 락**을 사용하지만, 특정 조건에 따라 **페이지 수준의 락**(page-level lock)이나 **테이블 수준의 락**(table-level lock)을 사용할 수 있습니다. 그러나 이러한 락은 상대적으로 더 큰 범위에 영향을 미치기 때문에, 행 수준의 락을 기본으로 사용하며 성능을 최적화합니다.

### **다중 트랜잭션이 동시에 동일한 행을 수정할 때의 자동 락 처리**
1. 트랜잭션 A와 트랜잭션 B가 동일한 행을 동시에 업데이트하려 할 때, **트랜잭션 A가 먼저** 락을 걸고 그 행을 수정하면, **트랜잭션 B는 그 행에 대해 락을 걸 수 없습니다**.
   - 트랜잭션 B는 `ELOCK`(대기 상태)로 대기하며, 트랜잭션 A가 **`COMMIT`**을 호출하여 락을 해제할 때까지 기다립니다.

2. 만약 트랜잭션 A가 오류로 **`ROLLBACK`**을 호출하면, 그 행에 설정된 락이 해제되며 트랜잭션 B가 다시 시도할 수 있게 됩니다.

### **행 수준 락 vs 테이블 수준 락**
- **행 수준 락**: 한 행만 잠그기 때문에 다른 트랜잭션에서 다른 행을 수정할 수 있습니다. **InnoDB**는 기본적으로 행 수준 락을 사용하여 **동시성을 높이고 성능을 최적화**합니다.
- **테이블 수준 락**: 테이블 전체에 대해 락을 걸어 모든 행에 대한 접근을 막습니다. 이는 **MyISAM** 엔진에서 주로 사용되며, **InnoDB**에서 사용되는 경우는 극히 드뭅니다.

---

### **결론**
InnoDB는 기본적으로 **자동으로 행 수준의 락**을 설정하여 데이터 정합성을 유지하고, 트랜잭션이 완료되면 락을 해제합니다. 따라서 개발자가 명시적으로 락을 설정하지 않더라도, **트랜잭션 처리 시 InnoDB는 자동으로 락을 관리**하여 동시성 문제를 해결합니다.

네, 맞습니다! **`FOR UPDATE`** 키워드 없이도 **InnoDB**에서는 **자동으로 락이 잡힙니다**. 하지만 **자동으로 잡히는 락**은 **`SELECT`**, **`UPDATE`**, **`DELETE`** 등의 SQL 문을 실행할 때 상황에 따라 다릅니다.

좀 더 구체적으로 설명하자면:

### 1. **`UPDATE` / `DELETE`** 문 실행 시
- **`UPDATE`**나 **`DELETE`**를 실행할 때, 해당 레코드에 대해 **자동으로 배타 락**(exclusive lock)이 잡힙니다.
- 즉, **`UPDATE`**를 통해 데이터를 수정하려면 그 행에 락이 걸리며, 다른 트랜잭션이 그 행을 수정할 수 없습니다.

예시:
```sql
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- 자동으로 배타 락이 걸림
COMMIT;
```
위 쿼리에서 `UPDATE`를 실행하면 **`id = 1`**인 레코드에 대해 **배타 락**이 자동으로 걸리고, 다른 트랜잭션이 이 레코드를 수정하려고 할 때 대기하거나 실패하게 됩니다.

### 2. **`SELECT` 문 실행 시**
- 기본적으로 **`SELECT`** 문은 **락을 걸지 않으며**, **`FOR UPDATE`**나 **`LOCK IN SHARE MODE`**를 명시적으로 사용하지 않으면 다른 트랜잭션에서 해당 레코드를 수정할 수 있습니다.
- 그러나 **InnoDB**는 **자동으로** **레코드를 읽는 도중** **읽기 락**(read lock)을 잠깐 걸 수 있는데, 이는 다른 트랜잭션이 동시에 해당 데이터를 수정하는 것을 방지할 수 있습니다. 하지만 읽기 락은 **다른 트랜잭션이 읽는 데 방해가 되지 않으며**, 기본적으로는 **행 수준 락**을 사용하지 않습니다.

예시:
```sql
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1;  -- 기본적으로 락이 걸리지 않음
COMMIT;
```

### 3. **`SELECT ... FOR UPDATE`** 문 실행 시
- **`FOR UPDATE`**를 사용하면, 그 행에 대해 **배타 락**이 자동으로 설정됩니다. 이를 통해 **다른 트랜잭션에서 해당 행을 수정할 수 없도록** 합니다.

예시:
```sql
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;  -- 배타 락이 자동으로 걸림
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
```
위 쿼리에서 **`FOR UPDATE`**를 사용하면 `id = 1`인 행에 대해 **배타 락**이 걸리고, 다른 트랜잭션은 이 레코드를 수정할 수 없습니다.

---

### 요약
- **`UPDATE`**나 **`DELETE`** 같은 수정 작업을 실행하면 **자동으로 배타 락**이 걸립니다.
- **`SELECT`** 문은 기본적으로 **자동 락을 걸지 않지만**, `FOR UPDATE`와 같은 명시적인 키워드를 사용하면 행에 대한 **배타 락**을 걸 수 있습니다.
- **`FOR UPDATE`**나 **`LOCK IN SHARE MODE`** 없이 `SELECT`를 실행할 때는 **락을 걸지 않으며**, 다른 트랜잭션에서 해당 데이터를 수정할 수 있습니다.

- 맞습니다! 기본적으로 **MySQL**에서 SQL 문은 트랜잭션 단위로 실행되는 것이 원칙입니다. 하지만, 트랜잭션을 명시적으로 **`START TRANSACTION`** 또는 **`BEGIN`** 명령어로 시작하지 않으면 **MySQL은 자동으로 트랜잭션을 관리**하게 됩니다. 이 동작은 **자동 커밋 모드 (Autocommit Mode)** 때문입니다.

### **자동 커밋 (Autocommit Mode)**
- **MySQL**의 기본 설정은 **자동 커밋 모드 (Autocommit mode)**가 **ON**인 상태입니다.
- 자동 커밋 모드가 켜져 있을 경우, 각 SQL 문은 **자동으로 트랜잭션 단위로 실행**되며, **각 쿼리가 실행될 때마다 자동으로 커밋**됩니다.
  - 즉, **트랜잭션을 명시적으로 시작하지 않아도**, **한 개의 SQL 문이 실행될 때마다 자동으로 커밋**됩니다.
  
이 설정에서는 **`START TRANSACTION`**이나 **`BEGIN`**을 명시하지 않아도, 각 SQL 문이 독립적인 트랜잭션처럼 작동하게 됩니다.

### 예시 (자동 커밋 모드에서의 실행):
```sql
-- 자동 커밋 모드가 켜져 있는 경우
-- 트랜잭션을 명시적으로 시작하지 않아도 자동으로 커밋됨

UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- 즉시 커밋됨
```

### **자동 커밋 모드 (Autocommit) 동작 방식**
1. **SQL 문 실행 후 즉시 커밋**: 각 SQL 문이 실행되면 바로 커밋됩니다.
2. **트랜잭션 제어 없이 실행**: 여러 SQL 문이 실행될 때도 별도의 트랜잭션 제어 없이 실행됩니다. 예를 들어, `UPDATE` 후 `INSERT`와 같은 쿼리들이 하나의 트랜잭션으로 묶이지 않습니다.

### **트랜잭션 명시적 제어**
- 만약 **트랜잭션을 수동으로 제어**하고 싶다면, **`START TRANSACTION`** 또는 **`BEGIN`**을 사용하여 트랜잭션을 시작하고, **`COMMIT`** 또는 **`ROLLBACK`**으로 트랜잭션을 종료할 수 있습니다.
  
```sql
-- 트랜잭션을 명시적으로 시작하는 예시
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;  -- 트랜잭션을 명시적으로 커밋
```

위의 예시에서는 **`START TRANSACTION`**으로 트랜잭션을 시작하고, **`COMMIT`**으로 트랜잭션을 종료하는 방식입니다. 이렇게 하면 두 개의 `UPDATE` 쿼리가 하나의 트랜잭션으로 묶여 **원자성**을 보장할 수 있습니다.

### **자동 커밋을 끄는 방법**
- 자동 커밋 모드를 끄려면 **`SET autocommit = 0;`** 명령을 사용합니다. 이 경우, **`START TRANSACTION`**을 사용해 트랜잭션을 수동으로 제어해야 합니다.

```sql
-- 자동 커밋을 끄고 트랜잭션을 수동으로 제어
SET autocommit = 0;  -- 자동 커밋 비활성화
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;  -- 트랜잭션을 명시적으로 커밋
```

### **자동 커밋 모드와 트랜잭션**
- **자동 커밋 모드**에서는 각 쿼리가 독립적으로 실행되기 때문에, 트랜잭션을 수동으로 제어하지 않아도 쿼리 실행 직후에 커밋됩니다.
- **자동 커밋을 비활성화**하면, 여러 SQL 문을 하나의 트랜잭션으로 묶을 수 있으며, **커밋**이나 **롤백**을 수동으로 제어할 수 있습니다.

### **결론**
- **MySQL**에서 **자동 커밋 모드**가 활성화되어 있으면, 각 SQL 문은 **트랜잭션 없이** 실행되고 바로 커밋됩니다.
- 트랜잭션을 **명시적으로 제어하려면** 자동 커밋 모드를 끄고 **`START TRANSACTION`** 또는 **`BEGIN`**으로 트랜잭션을 시작하여, **`COMMIT`** 또는 **`ROLLBACK`**으로 트랜잭션을 명시적으로 종료해야 합니다.

- 트랜잭션과 락의 고급 개념을 공부하는 데 있어 중요한 내용을 정리해보겠습니다.

### 1. 트랜잭션 격리 수준 (Isolation Levels)

트랜잭션 격리 수준은 트랜잭션이 서로 겹치지 않고 독립적으로 실행되도록 보장하는 수준을 의미합니다. **MySQL**에서는 트랜잭션 격리 수준을 설정하여 여러 트랜잭션이 동시에 실행될 때 발생할 수 있는 문제들을 제어할 수 있습니다. 격리 수준은 **Dirty Read**, **Non-repeatable Read**, **Phantom Read** 등을 처리하는 방식에 영향을 줍니다.

트랜잭션 격리 수준은 다음과 같습니다:

1. **READ UNCOMMITTED**
   - 트랜잭션이 아직 커밋되지 않은 데이터를 읽을 수 있음.
   - **Dirty Read**가 발생할 수 있음.
   - 가장 낮은 수준의 격리, 성능은 좋지만 데이터 일관성이 떨어짐.

2. **READ COMMITTED**
   - 트랜잭션이 커밋된 데이터만 읽을 수 있음.
   - **Non-repeatable Read**(한 트랜잭션이 읽은 데이터가 다른 트랜잭션에 의해 변경될 수 있음)가 발생할 수 있음.
   - 일관성은 어느 정도 보장되지만, 성능이 중간 정도임.

3. **REPEATABLE READ**
   - 트랜잭션이 시작된 시점부터 다른 트랜잭션이 데이터를 수정할 수 없음.
   - **Phantom Read**가 발생할 수 있음 (새로 삽입된 행을 읽을 수 있음).
   - MySQL의 기본 격리 수준으로 높은 일관성을 보장하지만, 성능은 다소 떨어질 수 있음.

4. **SERIALIZABLE**
   - 가장 높은 격리 수준으로, 트랜잭션이 완전히 직렬화되어 실행됨.
   - 트랜잭션 간 데이터의 충돌이 전혀 발생하지 않도록 보장.
   - 성능은 가장 낮지만, 데이터 일관성이 최고 수준으로 보장됨.

### 2. Deadlock (교착 상태) 처리

교착 상태는 두 개 이상의 트랜잭션이 서로 상대방이 가진 리소스를 기다리고 있어, 모든 트랜잭션이 무한 대기 상태에 빠지는 현상입니다. MySQL은 **InnoDB** 스토리지 엔진을 사용하여 교착 상태를 감지하고 이를 해결합니다.

교착 상태를 방지하기 위한 방법:
- **트랜잭션 순서**를 규칙적으로 설정하여 충돌을 피할 수 있습니다.
- **트랜잭션 롤백**을 통해 교착 상태 발생 시 자동으로 트랜잭션을 취소하고 시스템을 복구할 수 있습니다.

### 3. 락 종류와 락 해제

트랜잭션은 데이터에 접근하는 동안 다른 트랜잭션과의 충돌을 피하기 위해 락을 사용합니다. 락은 크게 **행 락**과 **테이블 락**으로 나눌 수 있습니다.

1. **행 락 (Row Lock)**
   - 트랜잭션이 특정 행에 대해서만 락을 걸어 다른 트랜잭션이 같은 행에 접근하지 못하게 합니다.
   - **InnoDB**에서 주로 사용되며, 동시성 처리에 유리합니다.

2. **테이블 락 (Table Lock)**
   - 트랜잭션이 테이블 전체에 락을 걸어 다른 트랜잭션이 해당 테이블에 접근하지 못하게 합니다.
   - 성능이 떨어지지만, 간단한 쿼리에서는 유리할 수 있습니다.

3. **공유 락 (Shared Lock)**
   - 여러 트랜잭션이 동시에 읽을 수 있도록 허용하지만, 쓰기는 방지합니다.

4. **배타 락 (Exclusive Lock)**
   - 트랜잭션이 데이터를 수정할 때 사용되며, 다른 트랜잭션은 해당 데이터를 읽거나 쓸 수 없습니다.

### 4. MySQL의 트랜잭션과 락 처리 방식

MySQL에서는 **InnoDB** 스토리지 엔진이 기본적으로 사용되며, 트랜잭션 처리와 락 관리가 중요합니다. **InnoDB**는 **행 수준 락**을 사용하여 성능을 최적화하고, **MVCC**(다중 버전 동시성 제어)를 통해 트랜잭션 간의 충돌을 최소화합니다.

- **InnoDB**는 **행 락**을 통해 다른 트랜잭션이 같은 행을 수정하지 않도록 방지합니다.
- **InnoDB**에서는 **자동 커밋**을 사용하지 않고, **수동으로 트랜잭션을 제어**하는 방식이 일반적입니다.

이 부분에 대한 학습을 진행하며, 트랜잭션 격리 수준과 락의 사용, 교착 상태 해결 방법을 실습해보면 좋습니다.

### **다음 단계**
- 트랜잭션 격리 수준을 설정하여 다양한 격리 수준을 비교하고, 각 트랜잭션이 다른 트랜잭션에 영향을 미치는 방식(Dirty Read, Non-repeatable Read, Phantom Read 등)을 실험해보세요.
- Deadlock을 발생시키고, MySQL에서 교착 상태가 어떻게 처리되는지 확인해보세요.
- InnoDB의 행 락과 테이블 락의 차이점과 성능을 비교해보세요.

이렇게 공부해보면 트랜잭션과 락을 깊이 이해할 수 있을 것입니다.

---
알겠습니다! MySQL을 기준으로 **트랜잭션 격리 수준(경리수준)**과 그에 따른 **락(Lock)** 동작을 설명하겠습니다. MySQL에서는 **격리 수준**과 **락**이 밀접하게 연결되어 있으며, 각 격리 수준에 따라 데이터의 **일관성**, **동시성**, **락의 사용 방식**이 달라집니다.

### 1. **트랜잭션 격리 수준 (Isolation Levels)**

MySQL에서 지원하는 트랜잭션 격리 수준은 총 4가지입니다. 각 격리 수준은 트랜잭션이 다른 트랜잭션의 데이터를 어떻게 볼 수 있는지에 대한 규칙을 정의합니다.

#### **1.1. READ UNCOMMITTED**
- **설명**: 트랜잭션이 **커밋되지 않은 데이터**도 읽을 수 있는 격리 수준입니다. 가장 낮은 격리 수준으로, 트랜잭션 간에 충돌이 발생할 가능성이 높습니다.
- **트랜잭션 A**와 **트랜잭션 B**가 동시에 작업할 때, **트랜잭션 A가 변경한 데이터를 트랜잭션 B가 읽을 수 있습니다.** 따라서 **더티 리드(Dirty Read)**가 발생할 수 있습니다.
- **락**: 트랜잭션이 데이터를 읽을 때 락을 걸지 않으므로 다른 트랜잭션이 자유롭게 데이터를 변경할 수 있습니다.

#### **1.2. READ COMMITTED**
- **설명**: 트랜잭션이 **커밋된 데이터**만 읽을 수 있습니다. 즉, 다른 트랜잭션이 커밋한 변경 사항만 읽을 수 있습니다.
- **트랜잭션 A**가 데이터를 읽은 후, **트랜잭션 B가 데이터를 수정하고 커밋**하면, **트랜잭션 A는 그 수정된 값을 읽을 수** 있습니다. 그러나 트랜잭션 A가 읽은 데이터가 다른 트랜잭션에 의해 변경되면 **반복 읽기(Read Skew)**가 발생할 수 있습니다.
- **락**: **SELECT** 쿼리에는 **공유락(SHARED LOCK)**이 사용됩니다. **UPDATE**, **DELETE**와 같은 쿼리에는 **배타적 락(EXCLUSIVE LOCK)**이 사용됩니다.

#### **1.3. REPEATABLE READ**
- **설명**: 트랜잭션이 시작된 이후, 그 트랜잭션 내에서 **읽은 데이터는 항상 동일**하게 유지됩니다. 트랜잭션이 처음 읽은 데이터는 **트랜잭션 종료 전까지 변경되지 않**습니다.
- **트랜잭션 A**가 **Alice의 잔액을 100원**으로 읽었다면, **트랜잭션 B가 같은 값을 수정**하더라도, 트랜잭션 A는 변경된 값을 보지 못합니다. 그러나 **팬텀 리드**(다른 트랜잭션에서 새로운 레코드를 삽입)가 발생할 수 있습니다.
- **락**: **SELECT** 쿼리에서 **행 단위 락**을 사용하며, **UPDATE**, **DELETE** 쿼리에는 **배타적 락**이 적용됩니다.

#### **1.4. SERIALIZABLE**
- **설명**: 가장 높은 격리 수준으로, 트랜잭션이 실행되는 동안 다른 트랜잭션은 **서로 영향을 주지 않**습니다. 이 격리 수준은 **동시성**을 완전히 제한하며, **성능 저하**를 초래할 수 있습니다.
- **트랜잭션 A**가 데이터를 읽은 후 **트랜잭션 B**가 데이터를 수정하려고 할 때, **트랜잭션 A가 끝날 때까지 트랜잭션 B는 대기**해야 합니다. 따라서 **팬텀 리드**가 발생하지 않으며, **행이 추가되거나 삭제되는 문제**도 방지됩니다.
- **락**: **행 단위 락**을 사용하며, 트랜잭션이 끝날 때까지 다른 트랜잭션이 데이터를 변경하지 못하도록 합니다.

### 2. **격리 수준별 락**

트랜잭션 격리 수준에 따라 **락**의 사용 방식이 달라집니다. MySQL에서 사용하는 **락 종류**는 **공유 락(SHARED LOCK)**과 **배타적 락(EXCLUSIVE LOCK)**입니다.

- **공유 락(SHARED LOCK)**: 다른 트랜잭션은 데이터를 읽을 수 있지만, 데이터를 수정할 수 없습니다. 예를 들어, **SELECT** 쿼리는 공유 락을 사용합니다.
- **배타적 락(EXCLUSIVE LOCK)**: 다른 트랜잭션은 해당 데이터를 읽거나 수정할 수 없습니다. 예를 들어, **UPDATE**, **DELETE** 쿼리는 배타적 락을 사용합니다.

### 3. **MySQL에서의 트랜잭션 락 동작**

MySQL에서는 **InnoDB** 스토리지 엔진을 사용할 때 **행 단위 락**(row-level lock)을 사용합니다. 이는 **낮은 수준의 락**으로, 성능을 높이면서도 **동시성**을 관리할 수 있게 합니다. 하지만 **격리 수준**에 따라 락의 적용 방식이 달라집니다.

#### **3.1. READ UNCOMMITTED**
- **락**: 락을 걸지 않기 때문에 **다른 트랜잭션이 데이터를 자유롭게 변경**할 수 있습니다.
- **더티 리드**가 발생할 수 있습니다. 즉, 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있습니다.

#### **3.2. READ COMMITTED**
- **락**: 읽을 때마다 **공유 락**을 사용하여 데이터를 읽고, **배타적 락**을 사용하여 데이터를 수정합니다.
- **반복 읽기(Read Skew)**가 발생할 수 있습니다. 한 트랜잭션이 데이터를 읽고 다른 트랜잭션이 데이터를 수정한 후, 첫 번째 트랜잭션이 다시 데이터를 읽으면 **변경된 값**을 보게 됩니다.

#### **3.3. REPEATABLE READ**
- **락**: **행 단위 락**을 사용하여 읽은 데이터를 변경할 수 없도록 방지합니다. **배타적 락**도 사용하여 데이터를 수정하려는 다른 트랜잭션을 방지합니다.
- **팬텀 리드**가 발생할 수 있습니다. 예를 들어, 트랜잭션 A가 특정 조건에 맞는 레코드를 읽은 후, 트랜잭션 B가 새로운 레코드를 추가하면, 트랜잭션 A는 **그 추가된 데이터를 읽을 수 없습니다**.

#### **3.4. SERIALIZABLE**
- **락**: 트랜잭션이 **전체 테이블을 잠그는 방식**으로, **행 단위 락** 외에도 **테이블 락**을 사용할 수 있습니다. 트랜잭션이 끝날 때까지 다른 트랜잭션이 해당 테이블의 데이터를 수정하거나 삽입할 수 없습니다.
- **팬텀 리드**가 완전히 방지됩니다.

### 4. **MySQL에서 트랜잭션 격리 수준 설정**

MySQL에서 트랜잭션 격리 수준을 설정하려면, **SET TRANSACTION ISOLATION LEVEL** 명령어를 사용합니다.

```sql
-- 트랜잭션 격리 수준 설정 예시
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

-- 트랜잭션이 시작되고, REPEATABLE READ 수준에서 작업을 처리
SELECT * FROM accounts WHERE name = 'Alice';
-- 이후 UPDATE, DELETE 쿼리 실행

COMMIT;  -- 트랜잭션 완료
```

### 결론

- **READ UNCOMMITTED**: 가장 낮은 격리 수준으로, **더티 리드**가 발생할 수 있습니다. 락을 최소화하여 **성능을 우선**으로 합니다.
- **READ COMMITTED**: 커밋된 데이터만 읽을 수 있으며, **반복 읽기**가 발생할 수 있습니다. 다른 트랜잭션이 데이터를 수정할 때마다 **변경된 값을 반영**합니다.
- **REPEATABLE READ**: 데이터를 읽을 때마다 동일한 값을 보장하며, **팬텀 리드**가 발생할 수 있습니다. MySQL의 기본 격리 수준입니다.
- **SERIALIZABLE**: 가장 높은 격리 수준으로, 모든 트랜잭션이 **순차적으로 실행**됩니다. **성능 저하**가 발생할 수 있지만, **팬텀 리드**를 완전히 방지합니다.

각 격리 수준을 선택할 때는 **성능**과 **데이터 일관성** 사이의 균형을 고려하는 것이 중요합니다.

MySQL에서 쿼리 성능을 분석하는 주요 도구 중 하나는 `EXPLAIN`입니다. 이 명령어를 사용하면 쿼리의 실행 계획을 확인하고, 쿼리가 어떻게 실행될지에 대한 정보를 제공합니다. 아래에 예제와 함께 설명하겠습니다.

### 1. EXPLAIN 사용법

`EXPLAIN`을 사용하면 쿼리가 실행되기 전에 MySQL이 어떻게 실행할지에 대한 정보를 얻을 수 있습니다. 이 명령어는 `SELECT`, `DELETE`, `INSERT`, `UPDATE` 쿼리 앞에 붙여서 사용합니다.

#### 예제:
```sql
EXPLAIN SELECT * FROM employees WHERE department = 'Sales';
```

#### EXPLAIN 출력 설명:
EXPLAIN 결과에는 여러 가지 열이 있습니다. 주요 열은 다음과 같습니다:

- **id**: 쿼리의 각 단계(혹은 서브쿼리)의 ID를 나타냅니다. 복잡한 쿼리에서 여러 번 실행되는 부분을 구별하는 데 유용합니다.
- **select_type**: 쿼리의 종류를 나타냅니다. 예를 들어, `SIMPLE`, `PRIMARY`, `UNION`, `SUBQUERY` 등이 있습니다.
- **table**: 데이터가 읽히는 테이블의 이름을 나타냅니다.
- **type**: 쿼리에서 사용된 조인의 종류를 나타냅니다. 가장 중요한 열로, `ALL`, `index`, `range`, `ref`, `eq_ref` 등이 있으며, `ALL`은 성능상 비효율적입니다.
- **possible_keys**: MySQL이 쿼리에서 사용할 수 있는 인덱스를 나열합니다.
- **key**: 실제로 사용된 인덱스를 보여줍니다.
- **key_len**: 사용된 인덱스의 길이를 나타냅니다.
- **ref**: 인덱스를 조회할 때 사용되는 컬럼을 나타냅니다.
- **rows**: MySQL이 예상하는 처리해야 할 행의 수입니다.
- **Extra**: 쿼리의 추가적인 정보 (예: `Using where`, `Using index`, `Using temporary`, `Using filesort` 등).

#### 예시 결과:
```plaintext
+----+-------------+-----------+-------+-------------------+---------+---------+------+---------+-----------------------+
| id | select_type | table     | type  | possible_keys     | key     | key_len | ref  | rows    | Extra                 |
+----+-------------+-----------+-------+-------------------+---------+---------+------+---------+-----------------------+
|  1 | SIMPLE      | employees | range | department_index  | dept_idx | 4       | NULL | 10      | Using where           |
+----+-------------+-----------+-------+-------------------+---------+---------+------+---------+-----------------------+
```

### 2. 쿼리 성능 최적화

쿼리 성능을 최적화하는 방법에는 여러 가지가 있습니다. 다음은 자주 사용되는 몇 가지 기법입니다.

#### 2.1. 인덱스 활용

인덱스를 적절히 사용하면 쿼리 성능을 크게 향상시킬 수 있습니다. 인덱스가 없는 경우 MySQL은 전체 테이블을 검색해야 하므로 성능이 저하됩니다.

예를 들어, `employees` 테이블에서 `department` 컬럼에 대해 자주 검색을 수행하는 경우, `department` 컬럼에 인덱스를 추가하는 것이 성능을 향상시킬 수 있습니다.

```sql
CREATE INDEX dept_idx ON employees(department);
```

인덱스가 있는 경우 `EXPLAIN` 출력에서 `type`이 `range`로 표시되고, `key` 열에 인덱스 이름이 나타나면 인덱스를 잘 활용하고 있다는 의미입니다.

#### 2.2. 서브쿼리 최적화

서브쿼리가 있는 쿼리는 성능에 영향을 미칠 수 있습니다. 이를 최적화하려면 서브쿼리를 `JOIN`으로 변경하거나, 필요한 데이터를 미리 조회하여 처리하는 방법을 사용할 수 있습니다.

서브쿼리 예:
```sql
SELECT * FROM employees WHERE department IN (SELECT department FROM departments WHERE location = 'New York');
```

이 쿼리를 `JOIN`으로 변경하여 성능을 개선할 수 있습니다:
```sql
SELECT e.* FROM employees e
JOIN departments d ON e.department = d.department
WHERE d.location = 'New York';
```

#### 2.3. LIMIT 사용

쿼리에서 필요한 데이터만 조회하려면 `LIMIT` 절을 사용하는 것이 좋습니다. 전체 데이터를 조회하는 것보다는 필요한 부분만 조회하는 것이 성능에 유리합니다.

```sql
SELECT * FROM employees LIMIT 10;
```

#### 2.4. 불필요한 컬럼 조회 방지

쿼리에서 필요한 컬럼만 선택하는 것이 성능에 좋습니다. `SELECT *`는 불필요한 컬럼까지 모두 조회하므로 성능이 저하될 수 있습니다.

```sql
SELECT name, department FROM employees;
```

### 3. 쿼리 최적화 분석

`EXPLAIN`을 사용하여 쿼리 성능을 분석한 후, `type`, `key`, `rows`, `Extra`와 같은 정보를 바탕으로 최적화 작업을 진행할 수 있습니다. 예를 들어, `ALL`이 표시되면 테이블 스캔을 의미하므로 인덱스를 추가하거나 쿼리 구조를 변경해야 할 필요가 있습니다.

### 4. 추가 도구 및 기법

- **MySQL Workbench**: 쿼리 성능 분석을 위한 GUI 도구로, 시각적으로 쿼리 성능을 분석하고 최적화할 수 있습니다.
- **Slow Query Log**: MySQL 서버에서 성능이 저조한 쿼리를 기록하여 분석할 수 있는 로그입니다. 이를 통해 자주 실행되는 느린 쿼리를 찾아 최적화할 수 있습니다.

### 요약

- `EXPLAIN`을 사용하여 쿼리의 실행 계획을 확인하고 성능을 분석합니다.
- 인덱스를 적절히 사용하고, 서브쿼리를 `JOIN`으로 변환하는 등 다양한 최적화 기법을 적용합니다.
- `LIMIT`과 필요한 컬럼만 조회하는 방법으로 쿼리 성능을 개선할 수 있습니다.
- `EXPLAIN` 결과를 바탕으로 쿼리 성능을 분석하고, 인덱스와 쿼리 구조를 최적화해야 합니다.

이제 `EXPLAIN`과 쿼리 최적화 방법에 대해 좀 더 이해할 수 있게 되었을 것입니다. 실습을 통해 직접 쿼리를 작성하고 성능을 분석해보는 것도 좋은 학습 방법입니다!

알겠습니다! MySQL 기준으로 **SQL 성능 최적화 및 인덱스**에 대한 예시를 자세히 설명하겠습니다.

### 1. **SQL 성능 최적화 예시**

#### 1.1 **불필요한 데이터 검색 줄이기**

예를 들어, `employees` 테이블에서 직원의 이름과 부서만 필요할 때 전체 테이블을 SELECT하는 것은 비효율적입니다. 필요한 컬럼만 선택하는 것이 좋습니다.

```sql
-- 비효율적 예시
SELECT * FROM employees;

-- 효율적 예시
SELECT name, department FROM employees;
```
`SELECT *`를 사용하면 불필요한 데이터를 모두 가져오기 때문에 성능이 떨어집니다. 따라서 필요한 컬럼만 선택하여 성능을 최적화해야 합니다.

#### 1.2 **WHERE 절 최적화**

`WHERE` 절에서 조건을 최적화해야 합니다. 예를 들어, `LIKE` 연산자나 `OR` 조건은 성능을 저하시킬 수 있으므로, 가능한 효율적인 조건으로 변경해야 합니다.

```sql
-- 비효율적 예시
SELECT * FROM employees WHERE name LIKE '%John%';

-- 효율적 예시
SELECT * FROM employees WHERE name = 'John';
```

`LIKE '%John%'`은 인덱스를 사용할 수 없기 때문에 성능에 큰 영향을 미칩니다. 대신 `LIKE` 조건을 `=`와 같은 정확한 비교로 변경하는 것이 성능을 개선할 수 있습니다.

#### 1.3 **조인 최적화**

조인 쿼리에서 불필요한 테이블을 조인하면 성능이 떨어질 수 있습니다. 필요한 테이블만 조인하고, `JOIN` 조건을 명확히 해야 합니다.

```sql
-- 비효율적 예시
SELECT * 
FROM employees e 
JOIN departments d ON e.department_id = d.department_id 
JOIN salaries s ON e.employee_id = s.employee_id;

-- 효율적 예시
SELECT e.name, d.department_name 
FROM employees e 
JOIN departments d ON e.department_id = d.department_id;
```
위 예시에서 `salaries` 테이블은 불필요하게 조인되고 있습니다. 실제로 필요한 데이터만 가져오는 쿼리로 최적화해야 합니다.

### 2. **인덱스 (Index)**

#### 2.1 **단일 컬럼 인덱스 예시**

단일 컬럼 인덱스는 특정 컬럼에 대해 검색 성능을 향상시킵니다. 예를 들어, `employees` 테이블에서 `name` 컬럼에 대해 인덱스를 추가하려면 다음과 같이 할 수 있습니다.

```sql
-- 단일 컬럼 인덱스 생성
CREATE INDEX idx_name ON employees(name);
```

이 인덱스를 생성하면 `name` 컬럼을 기준으로 검색할 때 성능이 크게 향상됩니다.

```sql
-- 인덱스를 활용한 검색
SELECT * FROM employees WHERE name = 'John';
```

이 쿼리는 `name` 컬럼에 인덱스가 있을 경우 더 빠르게 실행됩니다.

#### 2.2 **복합 인덱스 예시**

복합 인덱스는 여러 컬럼을 조합하여 인덱스를 생성하는 방식입니다. 예를 들어, `employees` 테이블에서 `name`과 `department_id` 컬럼에 대해 복합 인덱스를 생성하려면 다음과 같이 할 수 있습니다.

```sql
-- 복합 인덱스 생성
CREATE INDEX idx_name_department ON employees(name, department_id);
```

이 복합 인덱스를 사용하면 `name`과 `department_id` 컬럼을 동시에 조건으로 사용하는 쿼리에서 성능이 향상됩니다.

```sql
-- 인덱스를 활용한 복합 조건 검색
SELECT * FROM employees WHERE name = 'John' AND department_id = 3;
```

복합 인덱스는 여러 컬럼을 동시에 사용할 때 성능을 최적화할 수 있습니다.

#### 2.3 **유니크 인덱스 예시**

유니크 인덱스는 컬럼의 값이 고유해야 한다는 제약을 두는 인덱스입니다. 예를 들어, `email` 컬럼에 대해 유니크 인덱스를 추가하려면 다음과 같이 할 수 있습니다.

```sql
-- 유니크 인덱스 생성
CREATE UNIQUE INDEX idx_email ON employees(email);
```

이 인덱스를 생성하면 중복된 이메일 값이 삽입될 수 없게 됩니다.

```sql
-- 유니크 인덱스를 활용한 중복 값 방지
INSERT INTO employees (name, email) VALUES ('John', 'john@example.com');  -- 성공
INSERT INTO employees (name, email) VALUES ('Jane', 'john@example.com');  -- 실패 (중복 이메일)
```

#### 2.4 **Full-Text 인덱스 예시**

Full-Text 인덱스는 텍스트 기반의 컬럼에서 빠른 검색을 위해 사용됩니다. 예를 들어, `description` 컬럼에 대해 Full-Text 인덱스를 추가하려면 다음과 같이 할 수 있습니다.

```sql
-- Full-Text 인덱스 생성
CREATE FULLTEXT INDEX idx_description ON employees(description);
```

이 Full-Text 인덱스를 사용하면 텍스트 검색에서 성능이 크게 향상됩니다.

```sql
-- Full-Text 검색
SELECT * FROM employees WHERE MATCH(description) AGAINST('software development');
```

위 쿼리는 `description` 컬럼에서 "software"와 "development"를 포함하는 레코드를 빠르게 찾을 수 있습니다.

### 3. **EXPLAIN을 사용한 성능 분석**

`EXPLAIN` 명령어는 MySQL 쿼리의 실행 계획을 확인하여 성능을 분석할 수 있는 유용한 도구입니다.

```sql
EXPLAIN SELECT * FROM employees WHERE name = 'John';
```

이 명령어는 MySQL이 쿼리를 실행하기 위해 사용하는 실행 계획을 출력합니다. `EXPLAIN`을 사용하여 쿼리의 성능 병목을 파악하고 인덱스 활용 여부, 테이블 접근 방식 등을 분석할 수 있습니다.

#### EXPLAIN 결과 예시:
```sql
EXPLAIN SELECT * FROM employees WHERE name = 'John';
```

출력 예시:
```
+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------------+
| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra       |
+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------------+
|  1 | SIMPLE      | employees | ref   | idx_name      | idx_name | 1022    | const |    5 | Using where |
+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------------+
```

- `key`: 사용된 인덱스를 나타냅니다. 예시에서는 `idx_name` 인덱스가 사용되었습니다.
- `rows`: 쿼리가 스캔한 행 수를 나타냅니다. 이 값이 적을수록 성능이 좋습니다.
- `Extra`: 추가적인 쿼리 실행 정보를 제공합니다. "Using where"는 WHERE 절에서 추가적인 필터링을 했음을 의미합니다.

### 4. **인덱스 관련 고려사항**

- **인덱스가 많으면 성능이 떨어질 수 있습니다**. 인덱스는 읽기 성능을 향상시킬 수 있지만, 쓰기 작업에서는 성능 저하를 일으킬 수 있습니다. 따라서 자주 업데이트되지 않는 컬럼에만 인덱스를 생성하는 것이 좋습니다.
- **인덱스를 사용할 때는 인덱스가 적절하게 설정되었는지 확인해야 합니다**. 모든 쿼리가 인덱스를 사용하지는 않기 때문에 `EXPLAIN`을 활용하여 인덱스 사용 여부를 분석해야 합니다.

### 결론

SQL 성능 최적화와 인덱스 활용은 데이터베이스 성능을 높이는 중요한 부분입니다. 각 상황에 맞게 적절한 인덱스를 생성하고, 쿼리 최적화를 통해 성능을 개선할 수 있습니다. `EXPLAIN` 명령어를 활용하여 쿼리 성능을 분석하는 것도 중요한 방법입니다.

다음 학습 항목을 원하시면 말씀해 주세요!





