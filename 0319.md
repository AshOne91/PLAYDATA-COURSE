# 가입고객 이탈 예측
판다스
```
엑셀처럼 데이터를 다룰수 있는 작은 프레임웍
시리즈
 1차원 배열
데이터 프레임
 2차원 배열

판다스의 인덱스의 개념은 키의 개념이 아니다.
```

슬라이싱 정수는 start : end - 1
슬라이싱 문자열은 start : end

판다스
```
시리즈 들의 집합
딕셔너리, 리스트, 넘파이 배열 등으로 생성가능
csv 파일이나 text, xlsx 등의 데이터를 판다스 객체로 생
```

Axis개념
(0, 1, 2, 3, 4) -> vector라 생각하기
axis = 0, axis = 1, axis = 2, axis = 3, axis = 4

데이터에서 NaN -> 결측(데이터가 없다)

df.info()시 중간에 쓰레기 값이 있을 수 있다.

수치형 데이터 리스트 뽑기
df.describe()

## **📌 평균과 중위수의 차이 + 이상치(Outlier) 고려**  

평균(Mean)과 중위수(Median)은 데이터의 중심 경향을 나타내는 대표적인 통계 지표지만, **이상치(Outlier)**가 포함되었을 때 두 값이 달라질 수 있습니다.  

---

## **1️⃣ 평균(Mean)과 중위수(Median)의 개념 정리**  
### ✅ **평균 (Mean)**
- 데이터 값들의 **총합을 데이터 개수로 나눈 값**  
\[
\text{Mean} = \frac{\sum X}{N}
\]
- 모든 데이터를 고려하기 때문에 **극단값(이상치)의 영향을 크게 받음**  
- 정규분포(대칭적인 분포)에서 대표값으로 많이 사용됨  

### ✅ **중위수 (Median)**
- 데이터를 **크기순으로 정렬했을 때 중앙에 위치한 값**  
- 데이터 개수가 **홀수**면 정가운데 값, **짝수**면 가운데 두 개의 평균  
- **이상치의 영향을 거의 받지 않음**, 데이터가 비대칭일 때 유용  

---

## **2️⃣ 이상치(Outlier)란?**
이상치는 **다른 데이터와 현저히 차이나는 극단적인 값**을 의미합니다.  
- **측정 오류**(데이터 입력 오류 등)  
- **극단적인 사건**(예: 특정 기업 CEO의 연봉)  
- **자연스러운 변동성**(예: 키, 몸무게 데이터에서 유독 큰 사람)  

🔹 **이상치의 예제**
```
[5, 7, 8, 9, 10, 15, 200]
```
→ 대부분 값이 5~15 범위에 있지만, **200**이 이상치.

---

## **3️⃣ 평균과 중위수의 차이 (이상치 포함 예제)**  

### **🔹 예제 1: 이상치가 없는 경우**
```
데이터: [1, 2, 3, 4, 5]
```
- 평균 = (1+2+3+4+5) / 5 = **3**  
- 중위수 = **3** (가운데 값)  
✅ **평균과 중위수가 동일**  

---

### **🔹 예제 2: 이상치가 있는 경우**
```
데이터: [1, 2, 3, 4, 100]
```
- 평균 = (1+2+3+4+100) / 5 = **22**  
- 중위수 = **3**  

❌ **평균이 22로 크게 왜곡됨!**  
✅ **중위수(3)는 이상치 영향을 거의 받지 않음**  

---

## **4️⃣ 평균 vs. 중위수 차이 및 활용 (이상치 포함)**  
|  | 평균(Mean) | 중위수(Median) |
|---|---|---|
| **계산 방식** | 모든 값을 더하고 개수로 나눔 | 데이터를 정렬한 후 중앙값 선택 |
| **이상치(Outlier) 영향** | 매우 큼 (왜곡 가능) | 거의 없음 (안정적) |
| **데이터 분포** | 정규분포(대칭)에 적합 | 비대칭 분포에도 적합 |
| **활용 사례** | 평균 연봉, 평균 점수, 온도 | 소득, 부동산 가격, 중앙 연봉 |

### **📍 실생활 예제: 연봉 데이터**
```
연봉 데이터: [3천만 원, 3천5백만 원, 4천만 원, 5천만 원, 10억 원]
```
- 평균 연봉: (0.3 + 0.35 + 0.4 + 0.5 + 10) / 5 = **2.31억 원**  
- 중위수 연봉: **4천만 원** (실제 대부분의 연봉과 유사)  

➡ **평균은 극단적인 부자(10억 원) 때문에 현실과 동떨어짐**  
➡ **이런 경우 중위수가 더 신뢰할 수 있는 지표**  

---

## **5️⃣ 결론: 평균과 중위수, 언제 사용할까?**
✅ **정규분포(대칭적인 데이터) → 평균 사용**  
✅ **이상치가 많거나, 데이터가 비대칭적일 때 → 중위수 사용**  
✅ **소득, 부동산, 의료 데이터 분석 → 중위수 활용 추천**  

💡 **즉, 평균은 ‘전체적인 경향’을, 중위수는 ‘실제 대표값’을 보여줍니다!**

`df.describe(include='object')`는 **문자열(범주형) 데이터**에 대한 요약 통계를 제공합니다.  
각 항목의 의미는 다음과 같습니다.  

| 항목 | 의미 |
|------|------|
| **count** | 해당 열의 **총 데이터 개수** (결측값 제외) |
| **unique** | **유일한 값의 개수** (중복 제외) |
| **top** | **가장 많이 등장한 값** (최빈값) |
| **freq** | **top 값이 등장한 횟수** |

---

### **🔹 예제**
```python
import pandas as pd

data = {'Category': ['A', 'B', 'A', 'C', 'B', 'A', 'A']}
df = pd.DataFrame(data)

print(df.describe(include='object'))
```
**📌 출력 결과**
```
       Category
count        7
unique       3
top          A
freq         4
```
📌 **해석:**  
- `count = 7` → 총 7개의 데이터  
- `unique = 3` → 'A', 'B', 'C' 총 3가지  
- `top = A` → 가장 많이 등장한 값  
- `freq = 4` → 'A'는 4번 등장  

✔ **문자열 데이터의 빈도 분석 시 유용함!**

# 데이터프레임
```
info()
  1. 데이터 타입 정보
  2. 결측치 여부
  3. 결측치가 없어도 수치형인데, 타입이 object이면, 수치형외에 다른데이터가 포함되어 이다.
  4. 인덱스가 정렬되어 있는지 여부
describe() 통계적 분석 4분위수 및 최대 최소 카운트
  -> 수치형 데이터
  -> 범주형 include = 'object'
      최빈값, 유니크, 빈도수,
  -> 위의 두가지를 다 출력 include='all'
isna() : 결측치 여부 확인
isna().sum() or isna().mean()
temp = df.isna().sum()
temp[temo>0] : 결측치가 있는 데이터의 컬럼명과 합을 시리즈로
```
### **📌 데이터프레임 분석 함수 요약**

1. **`info()`**  
   - **데이터 타입 정보**: 각 컬럼의 데이터 타입 확인  
   - **결측치 여부**: 각 컬럼의 결측치 개수 및 데이터 수량 확인  
   - **수치형 데이터의 object 타입 문제**: 수치형 데이터가 `object` 타입으로 표시되면, 비수치형 데이터가 포함된 경우가 있음  
   - **인덱스 정렬 여부**: 인덱스가 정렬되어 있는지 여부 확인  

   ```python
   df.info()
   ```

2. **`describe()`**  
   - **수치형 데이터**: 4분위수, 평균, 표준편차, 최소값, 최대값 등 통계적 정보 출력  
   - **범주형 데이터**: `include='object'`로 설정하여 **최빈값**, **유니크 값**, **빈도수** 출력  
   - **모든 데이터 출력**: `include='all'`을 사용하여 수치형과 범주형 데이터를 모두 출력  

   ```python
   df.describe()             # 기본 수치형 데이터
   df.describe(include='all')  # 수치형 + 범주형 데이터
   ```

3. **`isna()`**  
   - **결측치 여부**: 각 셀의 결측치 여부를 True/False로 반환  

   ```python
   df.isna()  # 결측치 여부 확인
   ```

4. **`isna().sum()`**  
   - 각 컬럼의 결측치 개수를 반환  

   ```python
   df.isna().sum()  # 결측치 개수
   ```

5. **`isna().mean()`**  
   - 각 컬럼의 결측치 비율을 반환  

   ```python
   df.isna().mean()  # 결측치 비율
   ```

6. **결측치가 있는 컬럼 확인**  
   - 결측치가 있는 컬럼명과 해당 컬럼의 결측치 개수를 시리즈로 반환  

   ```python
   temp = df.isna().sum()
   temp[temp > 0]  # 결측치가 있는 컬럼 및 개수
   ```

---

### **🚀 정리**  
- **`info()`**: 데이터 타입, 결측치 여부, 인덱스 정렬 여부 확인  
- **`describe()`**: 수치형/범주형 데이터의 통계적 요약  
- **`isna()`**: 결측치 여부 확인  
- **`isna().sum()`**: 결측치 개수  
- **`isna().mean()`**: 결측치 비율  
- **`isna().sum() > 0`**: 결측치가 있는 컬럼 확인

좋은 질문입니다! **`pd.DataFrame()`에서 `df`의 컬럼이 행으로 변하는 이유**에 대해 자세히 설명드리겠습니다.

### 📌 `DataFrame`에서 행과 열의 개념

- **행 (Row)**: 데이터의 수평적 항목. 각 행은 데이터베이스의 한 레코드, 혹은 `DataFrame`의 하나의 관측값을 나타냅니다.
- **열 (Column)**: 데이터의 수직적 항목. 각 열은 **특정 특성**이나 **속성**을 나타냅니다. 예를 들어, 나이, 성별, 수입 등.

따라서, **기본적으로 `DataFrame`은 `컬럼`을 세로로 보고, `행`은 가로로 봅니다.**

### 📌 `DataFrame`을 생성할 때, **딕셔너리**로 데이터를 넣는 경우:

```python
pd.DataFrame({
    'Data_Type': df.dtypes,
    'Missing_count': df.isna().sum(),
    'Missing_Ratio(%)': df.isna().mean() * 100
})
```

이 경우, **딕셔너리**의 **키**는 **열 이름**이 되고, **값**은 **각 컬럼에 대한 통계 값**입니다.

---

### 📌 왜 `df`의 **컬럼**이 **행**이 되는지?

이 코드를 작성했을 때, `df`의 **컬럼 이름**이 **행 인덱스**로 설정되는 이유는, `pd.DataFrame()` 안에서 **딕셔너리**의 **값**을 **열(column)**로 설정하고, **키**를 **행(index)**로 설정하기 때문입니다.

**딕셔너리**의 키를 **행 이름(index)**로 설정하고, 딕셔너리의 **값**을 **열(column)**로 취급하는 방식입니다.

즉, 다음과 같이 `pd.DataFrame()` 내부에서 **`df.columns`**를 행 이름으로 사용하고 있는 것입니다:

- `df.dtypes`, `df.isna().sum()`, `df.isna().mean() * 100`의 값들이 **열(column)**로 들어갑니다.
- **`df.columns`**에 들어 있는 **컬럼 이름**이 **행(index)**으로 자동 설정됩니다.

---

### 📌 예시로 살펴보자

#### 원본 DataFrame (`df`):

```python
import pandas as pd

df = pd.DataFrame({
    'age': [25, 30, 35, None, 45],
    'salary': [50000, 60000, None, 80000, 90000],
    'gender': ['M', 'F', 'M', 'F', None],
    'department': ['HR', 'IT', 'IT', 'HR', 'Finance']
})
```

#### 딕셔너리를 이용한 `summary` DataFrame 생성

```python
summary = pd.DataFrame({
    'Data_Type': df.dtypes,
    'Missing_count': df.isna().sum(),
    'Missing_Ratio(%)': df.isna().mean() * 100
})

print(summary)
```

**출력 결과:**

```
            Data_Type  Missing_count  Missing_Ratio(%)
age               float64              1               20.0
salary            float64              1               20.0
gender            object               1               20.0
department        object               0                0.0
```

#### **설명:**

- **열(Column)**: `Data_Type`, `Missing_count`, `Missing_Ratio(%)`는 딕셔너리의 **값**에 해당하는 열들입니다.
- **행(Row)**: `age`, `salary`, `gender`, `department`는 딕셔너리의 **키**입니다. 이 키들이 **행**으로 들어갑니다.

---

### 📌 요약

- **딕셔너리**에서 **값**들은 `DataFrame`의 **열**로 배치됩니다.
- **딕셔너리의 키**는 **행 이름(index)**로 사용됩니다.
- `df`의 **컬럼 이름**들은 **행 이름(index)**로 사용되어 결과적으로 `summary`에서 **행**으로 출력됩니다.

이렇게 **열**과 **행**을 정의하는 방식은 **딕셔너리의 키와 값**이 어떻게 배치되는지에 따라 결정됩니다.
