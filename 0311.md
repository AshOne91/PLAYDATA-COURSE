# SQL 기본개념
sql : 데이터베이스를 정의하고 조작하는 언어, 질의어
주요명령어
  DDL(Data Definition Laguage) : Create, Alter, Drop
  DML(Data Manipulation Laguage) : insert, select, update, delete data CRUD
  DCL(Data Control Laguage) : grant, revoke 권한부여 삭제
함수 : 데이터 가공 및 계산을 위한 내장 함수 

DBeaver, DBToad 여러 관리툴이 있음

### **📌 SQL 분석: `SELECT concat(ELT(1+rand()*5, '김', '이', '박', '최', '정')) AS name;`**

이 SQL 문은 **MySQL에서 무작위로 성(姓)을 선택하여 반환**하는 쿼리입니다.

---

### **🔎 쿼리 상세 분석**  

1. **`RAND()`**  
   - `RAND()`는 0 이상 1 미만의 **난수를 생성**합니다.  
   - 예를 들어 `RAND()`가 `0.7345`라면, `1 + RAND() * 5` 계산 시:
     ```sql
     1 + 0.7345 * 5 = 4.6725
     ```

2. **`1 + RAND() * 5`**  
   - `RAND() * 5` → `0 이상 5 미만`의 난수를 생성  
   - `1 + RAND() * 5` → `1 이상 6 미만`의 난수를 생성  
   - 즉, 결과값은 **`1.0 이상 5.9999...`** 범위 내의 값이 됨.

3. **`ELT(N, '김', '이', '박', '최', '정')`**  
   - `ELT(N, '김', '이', '박', '최', '정')`은 **N번째 요소를 반환**하는 함수  
   - `ELT(1, '김', '이', '박', '최', '정')` → `'김'`  
   - `ELT(2, '김', '이', '박', '최', '정')` → `'이'`  
   - `ELT(3, '김', '이', '박', '최', '정')` → `'박'`  
   - `ELT(4, '김', '이', '박', '최', '정')` → `'최'`  
   - `ELT(5, '김', '이', '박', '최', '정')` → `'정'`  

   **⚠️ 만약 난수 결과가 6 이상이 나오면 `ELT()`는 `NULL`을 반환**할 수 있음.  
   (MySQL의 `ELT()` 함수는 인덱스 범위를 초과하면 `NULL`을 반환)

4. **`CONCAT(...) AS name`**  
   - `CONCAT(...)`는 문자열을 연결하는 함수  
   - 여기서는 성(姓)만 선택하므로, `CONCAT(...)`는 없어도 동일한 결과를 반환  

---

### **🎯 실행 결과 예시**
```sql
+------+
| name |
+------+
| 이   |
+------+
```
또는
```sql
+------+
| name |
+------+
| 박   |
+------+
```
실행할 때마다 무작위로 `'김'`, `'이'`, `'박'`, `'최'`, `'정'` 중 하나가 출력됨.

---

### **✅ 보완할 점**
`1 + RAND() * 5`가 6에 가까운 값이 나오면 `ELT()`가 `NULL`을 반환할 가능성이 있음.  
이를 방지하려면 **`FLOOR()`**를 사용하여 정수로 변환하는 것이 더 안전함.

```sql
SELECT ELT(FLOOR(1 + RAND() * 5), '김', '이', '박', '최', '정') AS name;
```
✔️ `FLOOR()`를 사용하면 `1, 2, 3, 4, 5`만 생성되어 `NULL`이 나올 가능성이 없음.  

---

### **🚀 확장 예제 (랜덤 이름 생성)**
랜덤한 이름을 만들려면 성(姓)과 이름을 조합할 수도 있음.

```sql
SELECT 
    CONCAT(
        ELT(FLOOR(1 + RAND() * 5), '김', '이', '박', '최', '정'), 
        ELT(FLOOR(1 + RAND() * 5), '민수', '지훈', '예은', '도현', '서윤')
    ) AS full_name;
```
실행할 때마다 `'김민수'`, `'이서윤'`, `'박지훈'` 등 랜덤한 이름이 생성됨. 😊

데이터베이스에서 **인덱스(Index)가 1부터 시작하는 이유**는 주로 **SQL의 설계 철학과 전통적인 컴퓨터 과학적 관점**에서 비롯됩니다.  

---

## **🔹 1. SQL의 1-Based Indexing 철학**
SQL에서 `ELT(N, 'A', 'B', 'C', 'D')`와 같은 함수가 **1부터 시작하는 이유**는 **SQL이 데이터를 사람이 읽기 쉬운 방식으로 다루도록 설계되었기 때문**입니다.  

- **SQL의 배열, 리스트 기반 함수들은 1부터 시작**하는 것이 일반적입니다.  
- **데이터베이스에서는 "첫 번째 데이터"를 1번으로 인식**하는 것이 직관적이기 때문입니다.

### 📌 예시: `ELT()`
```sql
SELECT ELT(1, 'A', 'B', 'C'); -- 결과: 'A'
SELECT ELT(2, 'A', 'B', 'C'); -- 결과: 'B'
SELECT ELT(3, 'A', 'B', 'C'); -- 결과: 'C'
```
`ELT()` 함수는 1부터 시작하여 첫 번째 요소가 `ELT(1, ...)`로 접근됩니다.

---

## **🔹 2. 전통적인 데이터베이스 인덱스 설계**
### **📌 PK (Primary Key) & AUTO_INCREMENT**
- 데이터베이스에서 `AUTO_INCREMENT`로 자동 증가하는 기본 키(PK)는 **1부터 시작**하는 것이 기본 설정입니다.  
- 이유:
  1. **비즈니스 로직의 직관성**  
     - ID가 0부터 시작하면 사람이 데이터를 볼 때 혼란스러울 수 있음.  
     - 예: 고객 ID, 주문 번호 등의 관리 측면에서 `1, 2, 3, ...`이 자연스러움.  
  2. **NULL과 구별하기 위해**  
     - `0`을 사용할 경우, `NULL`과 혼동될 가능성이 있음.  
  3. **오래된 DB 시스템의 전통**  
     - 많은 RDBMS(Oracle, MySQL, PostgreSQL 등)는 오래전부터 기본 키를 1부터 시작하도록 설계됨.  

📌 **MySQL에서 `AUTO_INCREMENT` 기본값 예제**
```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL
);
```
위 테이블에서 `INSERT`를 수행하면 `id` 값이 `1, 2, 3, ...` 순서로 증가합니다.

---

## **🔹 3. 프로그래밍 언어와의 차이**
**프로그래밍 언어에서는 인덱스가 0부터 시작하는 경우가 많음**  
- **C, Java, Python** 등의 언어에서는 배열(Array)의 인덱스가 0부터 시작  
- 이유: **메모리 주소 연산의 편리함** (`0`이 시작 주소)  

📌 **Python 예제**
```python
arr = ['A', 'B', 'C']
print(arr[0])  # 'A'
print(arr[1])  # 'B'
```
하지만 **SQL에서는 사람이 데이터를 다루는 관점에서 "첫 번째"를 `1`로 간주**하기 때문에 다르게 동작합니다.

---

## **🔹 4. 예외적인 경우 (0부터 시작하는 데이터베이스)**
일부 데이터베이스 또는 설정에서는 **0부터 시작할 수도 있음**  
- `MySQL ENUM` 타입은 내부적으로 0부터 저장되지만, 사용자는 1부터 접근  
- `PostgreSQL` 배열은 1부터 시작하지만, `jsonb` 타입의 배열은 0부터 시작  

**✅ MySQL ENUM 예제**
```sql
CREATE TABLE example (
    category ENUM('small', 'medium', 'large')
);
```
- `small` = `1`
- `medium` = `2`
- `large` = `3`

하지만 내부적으로 `0`이 할당될 수도 있음.

---

## **🎯 결론: 데이터베이스 인덱스는 왜 1부터 시작할까?**
1️⃣ **SQL 철학:** 사람이 읽기 쉽게 하기 위해 (1-based)  
2️⃣ **DB 설계 관습:** AUTO_INCREMENT 등의 기본 키는 1부터 증가하는 것이 일반적  
3️⃣ **NULL과의 구분:** `0`을 NULL과 혼동하지 않도록 설계  
4️⃣ **프로그래밍 언어와 차이:** SQL은 사람이 다루기 쉽게 설계됨, 프로그래밍 언어는 메모리 구조상 0부터 시작  

**📌 정리하자면,**  
데이터베이스의 인덱스는 **프로그래머보다는 데이터 사용자(일반 사용자, 관리자) 중심**으로 설계되었기 때문에 **1부터 시작하는 것이 기본**입니다! 🚀

```
-- ELT(n, str1,str2,str3 ... )
--  n: 1부터시작하는 정수인덱스
-- str1, str2... 선택가능한 문자열 목록
-- 반환값 : n에 해당하는 위치의 문자열, 
-- 용도 : 랜덤데이터 생성
select floor(1+rand()*5);
select concat('hello',' world') as name;

-- 데이터 베이스 생성
create database if not exists student_db2; 
-- 테이블생성(학생)
    -- pk(id), name, age, kor, eng, math
create table if not exists student_db2.students(
    id int auto_increment primary key,
    name varchar(100) not null,
    age int not null,
    kor int ,
    eng int,
    math int
);
-- 테이블 생성확인을 위한 조회
select * from student_db2.students;

-- 데이터를 랜덤하게 생성
insert into student_db2.students(name,age,kor,eng,math) 
select
    concat(
        ELT(floor(1+rand()*8), '김','이','박','최','구','강','조','윤'),
        ELT(floor(1+rand()*5), '영희','철수','준호','철호','미나')                
    ) as name,
    floor(70+rand()*20) as age,
    floor(70+rand()*21) as kor,
    floor(70+rand()*21) as eng,
    floor(70+rand()*21) as math    
;

-- 테이블 생성확인을 위한 조회
select * from student_db2.students;

commit;
```
